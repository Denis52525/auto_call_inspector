import re
import requests
import json
import time
from collections import Counter
from config import MODEL_URL, MODEL_NAME, TEMPERATURE, MAX_SEGMENT_LENGTH
from loguru import logger


def get_speaker_roles(dialog_text: str, model_url=MODEL_URL, model_name=MODEL_NAME):
    system_prompt = """
        Ты — профессиональный аналитик телефонных звонков автосервиса. 
        Твоя задача — анализировать расшифровку разговора между Клиентом и Менеджером и давать точный структурированный отчёт.
        
        ТЫ ДОЛЖЕН:
        
        1. Чётко определять роли:
           - Клиент — спрашивает, жалуется, описывает проблему, интересуется ценой, временем, услугой.
           - Менеджер — отвечает, уточняет VIN/год/пробег, предлагает варианты, говорит про запись, условия сервиса.
        
        2. Формат ответа ДОЛЖЕН быть строго таким:
        
        {
          "Speaker 1": "Клиент или Менеджер",
          "Speaker 2": "Клиент или Менеджер"
        }
        
        НИЧЕГО ЛИШНЕГО ПИСАТЬ НЕ НАДО, ТОЛЬКО JSON.
    """

    prompt = system_prompt + "\n\nДиалог для анализа:\n" + dialog_text

    response = requests.post(
        model_url,
        json={
            "model": model_name,
            "prompt": prompt,
            "stream": False
        }
    )

    response.raise_for_status()
    data = response.json()

    text = data.get("response") or data.get("text") or ""

    clean_text = re.sub(r'^```json\s*', '', text)  # Убираем начало
    clean_text = re.sub(r'\s*```$', '', clean_text)
    try:
        roles = json.loads(clean_text)
    except json.JSONDecodeError:
        raise ValueError(f"Failed to parse JSON from model response:\n{clean_text}")

    return roles



system_prompt_1 = """
Твоя задача – проанализировать диалог между клиентом и менеджером.

ВАЖНО:
— Без пояснений.
— Если данных нет — ставь 0 или "".
— Также оцени ошибки менеджера и дай краткий комментарий в отдельном поле "Коментарий".
— Структура JSON должна быть строго такой же, как в шаблоне.

Используй такую структуру JSON:

{
 "Початок розмови, представлення": 0,
 "Чи дізнвся менеджер кузов атвомобіля": 0,
 "Чи дізнався менеджер рік автомобіля": 0,
 "Чи дізнався менеджр пробіг": 0,
 "Пропозиція про комплексну діагностику": 0,
 "Дізнався які роботи робилися раніше": 0,
 "Запис на сервіс, Дата": "",
 "Завершення розмови прощання": 0,
 "Коментарий": ""
 "Тип звернення": ""

}

ПРАВИЛА АНАЛІЗУ:

Початок розмови, представлення = 1 если менеджер поздоровался и представился, иначе 0.

Чи дізнвся менеджер кузов атвомобіля = 1 если спросил: модель, кузов, комплектацию (BMW F10 и т.п.), иначе 0.

Чи дізнався менеджер рік автомобіля = 1 если спросил год, иначе 0.

Чи дізнався менеджр пробіг = 1 если спросил пробег, иначе 0.

Пропозиція про комплексну діагностику = 1 если менеджер предлагал комплексную диагностику,иначе 0.

Дізнався які роботи робилися раніше = 1 если менеджер интересовался чем занимались ранее, что уже делали, иначе 0.

Запис на сервіс, Дата = дата и время, если запись была сделана. Если нет — "".

Завершення розмови прощання = 1 если менеджер попрощался, иначе 0.

Коментарий = коротко опиши, что менеджер сделал неправильно: плохо отвечал, отвечал не по теме, грубил, матерился, не соблюдал деловой тон, не задавал нужные вопросы и т.д. Если нарушений нет — оставь пустым "".

Тип звернення — выбери только один тип из списка:
1. "Консультація" — клиент задаёт вопросы или уточняет информацию, но машина ещё не в ремонте.
2. "Авто в роботі" — клиент сообщает о том, что автомобиль уже в ремонте, либо обсуждает текущие работы.
3. "Доставка" — обращение связано с привозом/забором автомобиля, запчастей или других предметов.
4. "Інше" — любое другое обращение, которое не подходит под вышеуказанные категории.

ВЫВОД:
Верни только JSON.
Начни ответ строго с символа { и закончи }.
Не пиши ничего вне JSON.
"""


system_prompt_2 = """
Твоя задача – проанализировать диалог между клиентом и менеджером.

ВАЖНО:
— Без пояснений.
— Если данных нет — ставь 0 или "".
— Структура JSON должна быть строго такой же, как в шаблоне.

Используй такую структуру JSON:

{
 "Чи дотримувався всіх інструкцій з топ 100 робіт Да/Ні": "",
 "Яких рекоменадцій менеджер не дотримувався з топ 100 робіт": "",
 "Результат": "",
 "Запчастини": "",
}

ПРАВИЛА АНАЛІЗУ:

Чи дотримувався всіх інструкцій з топ 100 робіт:
— Да = если менеджер спрашивал всё, что должен
— Ні = если что-то упущено

Яких рекоменадцій менеджер не дотримувався з топ 100 робіт: укажи конкретно (например: "не уточнил пробег", "не предложил диагностику", "не уточнил год авто").

Результат:
— "Запис" если записаласся
— "Передзвонити" если нужно перезвонить
— "Повторно консультація" если нужна повторная консультация
— "Передано іншому філіалу" если у их филиала нету возможности
— "Інше" если что-то другое

Запчастини:
— "Наші" если говорит о своих запчастях
— "Клієнта" если клиентские
— "Наші" если не упоминалось

ВЫВОД:
Верни только JSON.
Начни ответ строго с символа { и закончи }.
Не пиши ничего вне JSON.
"""


work_list = [
 "інший варіант",
 "комплексне ТО",
 "Компʼютерна діагностика",
 "Заміна Оливи ДВЗ",
 "Заміна повітряного фільтра ДВЗ",
 "Заміна сайлентблоків",
 "слюсарні роботи",
 "Комплексна діагностика",
 "Заміна фільтру салону",
 "Заміна масла в АКПП",
 "Заміна амортизатора переднього",
 "Ендоскопія двигуна",
 "Заміна свічок запалення",
 "Заміна гальмівних дисків та колодок",
 "Заміна оливи в передньому | задньому редукторі",
 "Заміна гальмівної рідини з прокачкою",
 "Заміна лампочки",
 "Зняття / встановлення важіля прд.",
 "Замір комрессії",
 "Замні та замовлення гальмівних колодок",
 "Заміна охолоджуючої рідини",
 "Заміна стійки стаблізатора переднього",
 "Заміна амортизатора зд.",
 "Заміна плаваючого сайлентблока.",
 "Заміна гальмівних дисків та колодок зд.",
 "Заміна фільтра салону в моторному відділенні",
 "Зняття/встановлення паливних форсунок",
 "Заміна пильовика амортизатора",
 "Арматурні работи",
 "Заміна свічок накалу",
 "Заміна ланцюгів ГРМ",
 "Зняття / встановлення впускного коллектора",
 "Димогенератор, пошук підсосів/витоку",
 "Реєстрація заміни АКБку",
 "Заміна АКБ",
 "Заміна свічок запалення N55",
 "Заміна еластичної муфти",
 "Ремонт електропроводки",
 "Заміна ланцюга ГРМ та масляного насосу N20",
 "Заміна ремкомплекту рейки",
 "Заміна подушки ДВЗ",
 "Знаття / встановлення піввісі",
 "Заміна подушки АКПП",
 "Зняття / встановлення теплообміника",
 "Знаття / встановлення маслостакана",
 "Заміна пружини",
 "Мийка / чистка деталі",
 "Зняття, встановлення Турбокомпресора",
 "Заміна помпи",
 "Заміна З-х сайлентблоків редуктора",
 "Заміна термостату",
 "Зняття / встановлення захисту двигуна",
 "Заміна прокладки маслостакана",
 "Заміна патрубка ОР",
 "Заміна приводного ремня",
 "Діагностика ДВЗ",
 "Зняття / встановлення кардану",
 "Заміна прокладки картера (піддону)",
 "Заміна КВКГ",
 "Заміна бачка ох. рідини",
 "Заміна втулки стабілізатора прд.",
 "Тестер витоку охолоджуючої рідини",
 "Зняття / встановлення вихлопної труби",
 "Заміна пильовика ШРУСа",
 "Діагностика течії",
 "Зняття / встановлення переднього бампера",
 "Заміна датчика",
 "Заміна переднього сальника колінвалу",
 "Заміна рульвої тяги",
 "Зняття / встановлення деталі",
 "Заміна котушки запалювання",
 "Зняття / встановлення інтеркулера",
 "Заміна кульової опори",
 "Розборка / зборка гальмівного супорта",
 "Заміна рульової тяги з наконечником",
 "Зняття / встановлення дверної ручки",
 "Зняття / встановлення повітряного патрубка",
 "Заміна клапана Vanos",
 "Заміна радіатору охолодження",
 "Заміна заднього сальника колінвалу та ремкомплект 8HP",
 "Заміна датчика кислороду (Лямбда)",
 "Заміна фланця роздавальної коробки",
 "Протікання води в салон через гідроізоляцію дверних карт"
]


def split_text(text, max_len=MAX_SEGMENT_LENGTH):
    segments = []
    start = 0
    while start < len(text):
        end = min(len(text), start + max_len)
        segments.append(text[start:end])
        start = end
    return segments


def analyze_segment(segment, work_list):
    system_prompt = f"""
Твоя задача – проанализировать диалог между клиентом и менеджером.
Выбери только одну работу из списка, которая соответствует обсуждённым проблемам в диалоге.

Список доступных работ: {work_list}

Правила:
— Верни только JSON с одним полем:
{{ "Яка робота з топ 100": "<выбранная работа>" }}
— Если подходящей работы нет — ставь "інший варіант".
— Никаких других полей или комментариев.
— Начни ответ строго с {{ и закончи }}.
"""

    prompt = system_prompt + "\n\nДиалог для анализа:\n" + segment

    response = requests.post(
        MODEL_URL,
        json={
            "model": MODEL_NAME,
            "prompt": prompt,
            "temperature": TEMPERATURE,
            "max_new_tokens": 2000,
            "stream": False
        }
    )
    data = response.json()
    answer = data.get("response", "").strip()
    return answer

def execute_prompt(prompt_name, system_prompt, dialog_text, additional_params=None):
    if prompt_name == "Prompt 3":
        segments =  split_text(dialog_text)
        results = []
        for seg in segments:
            try:
                result_json = analyze_segment(seg, work_list)
                parsed = json.loads(clean_json_text(result_json))
                results.append(parsed.get("Яка робота з топ 100", "інший варіант"))
            except Exception as e:
                logger.error(f"Segment processing error: {e}")
                results.append("інший варіант")

        counter = Counter(results)
        final_choice = counter.most_common(1)[0][0]
        result = {"Яка робота з топ 100": final_choice}
    else:
        prompt = system_prompt + "\n\nДиалог для анализа:\n" + dialog_text

        response = requests.post(
            MODEL_URL,
            json={
                "model": MODEL_NAME,
                "prompt": prompt,
                "temperature": TEMPERATURE,
                "max_new_tokens": 2000,
                "stream": False
            }
        )
        data = response.json()
        result = data.get("response", "").strip()

    return result


def clean_json_text(text: str) -> str:
    if not text:
        return json.dumps({"text": ""}, ensure_ascii=False)
    try:
        cleaned = re.sub(r'^```json\s*', '', text.strip(), flags=re.IGNORECASE)
        cleaned = re.sub(r'^```\s*', '', cleaned)
        cleaned = re.sub(r'\s*```$', '', cleaned)
        cleaned = cleaned.strip()
    except Exception:
        return json.dumps(text, ensure_ascii=False)

    try:
        json.loads(cleaned)
        return cleaned
    except json.JSONDecodeError:
        return json.dumps({"text": cleaned}, ensure_ascii=False)


def process_transcript_file(file_path):
    dialog_lines = []
    with open(file_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                dialog_lines.append(line)
    dialog_text = "\n".join(dialog_lines)

    manager_found = any("Менеджер:" in line for line in dialog_lines)

    if not manager_found:
        combined_results = [
            {
                "Початок розмови, представлення": 0,
                "Чи дізнвся менеджер кузов атвомобіля": 0,
                "Чи дізнався менеджер рік автомобіля": 0,
                "Чи дізнався менеджр пробіг": 0,
                "Пропозиція про комплексну діагностику": 0,
                "Дізнався які роботи робилися раніше": 0,
                "Запис на сервіс, Дата": "",
                "Завершення розмови прощання": 0,
                "Коментарий": "Не найден менеджер в разговоре",
                "Тип звернення": ""

        },
            {
                "Чи дотримувався всіх інструкцій з топ 100 робіт Да/Ні": "Ні",
                "Яких рекоменадцій менеджер не дотримувався з топ 100 робіт": "",
                "Результат": "",
                "Запчастини": ""
            },
            {
                "Яка робота з топ 100": "інший варіант"
            }
        ]
        return combined_results


    result1 = execute_prompt("Prompt 1", system_prompt_1, dialog_text)
    result2 = execute_prompt("Prompt 2", system_prompt_2, dialog_text)
    result3 = execute_prompt("Prompt 3", "", dialog_text)

    combined_results = [
        json.loads(clean_json_text(result1)),
        json.loads(clean_json_text(result2)),
        json.loads(clean_json_text(result3))
    ]

    return combined_results